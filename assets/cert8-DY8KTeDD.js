const e=[{section:"개발 환경과 형상관리",items:[{title:"개발 도구 분류",mnemonic:"빌구테형",summary:"빌드 도구, 구현 도구, 테스트 도구, 형상관리 도구로 분류",details:["빌드 도구","구현 도구","테스트 도구","형상관리 도구"]},{title:"운영체제 (OS)",mnemonic:null,summary:"하드웨어를 사용자가 편리하게 사용하도록 도와주는 소프트웨어",details:["사용자와 하드웨어 사이에서 자원 관리와 인터페이스 제공","예: Windows, Unix, Linux"]},{title:"웹서버",mnemonic:null,summary:"정적 콘텐츠(HTML, 이미지 등)를 처리하는 서버",details:["주로 정적 페이지와 정적 리소스를 제공","예: Apache HTTP Server, Nginx, Google Web Server 등"]},{title:"웹 애플리케이션 서버 (WAS)",mnemonic:null,summary:"동적 콘텐츠(JSP, 서블릿 등)를 처리하는 서버",details:["웹 애플리케이션 실행 환경 제공","비즈니스 로직 수행","예: Tomcat, WebLogic 등"]},{title:"클라이언트 프로그램",mnemonic:null,summary:"사용자가 설치하여 서버와 통신하는 프로그램",details:["사용자 단에서 실행되는 응용 프로그램","서버에 요청을 보내고 응답을 받는 역할"]},{title:"미들웨어",mnemonic:null,summary:"컴퓨터-컴퓨터 간 연결 및 연결 관리를 돕는 소프트웨어",details:["서버와 서버, 서버와 클라이언트 사이에서 통신·연계를 지원","예: WebLogic, Jeus, Tomcat"]},{title:"DBMS",mnemonic:null,summary:"사용자와 DB 사이에서 데이터 관리를 수행하는 소프트웨어",details:["데이터의 추가, 수정, 삭제, 조회 기능 제공","예: Oracle, MySQL 등"]},{title:"형상관리 (Configuration Management, CM)",mnemonic:null,summary:"소프트웨어 개발 과정에서 발생하는 변경사항을 체계적으로 관리하는 것",details:["소스코드, 문서, 설정 등 개발 산출물의 변경을 관리","버전 관리와 변경 이력 추적이 핵심"]},{title:"형상관리 절차",mnemonic:"식통감기",summary:"형상 식별 → 형상 통제 → 형상 감사 → 형상 기록",details:["1. 형상 식별: 관리 대상을 식별하고 번호 부여","2. 형상 통제: 형상통제위원회(CCB) 운영, 베이스라인 관리","3. 형상 감사: 형상 항목의 무결성 평가","4. 형상 기록: 변경 이력 및 상태를 기록·관리"]},{title:"형상관리 통제 위원회 (CCB)",mnemonic:null,summary:"형상관리 방침을 결정하고 변경을 승인·통제하는 조직",details:["형상 항목의 변경 요청을 심의·승인","베이스라인 변경 관리"]},{title:"베이스라인 (Baseline)",mnemonic:null,summary:"개발 산출물의 변화를 통제하기 시작하는 기준 시점",details:["이 시점 이후 변경은 CCB 승인 절차를 거쳐야 함","릴리즈나 마일스톤의 기준이 되는 상태"]},{title:"형상관리 도구 유형",mnemonic:"공클분",summary:"공유 폴더, 클라이언트/서버, 분산 저장소 방식",details:["1. 공유 폴더 방식: 완료된 파일을 공유 폴더에 복사하여 관리","2. 클라이언트/서버 방식: 중앙 서버에서 버전 관리 시스템이 동작","3. 분산 저장소 방식: 로컬 저장소와 원격 저장소가 분산"]},{title:"형상관리 도구별 특징",mnemonic:null,summary:"RCS, CVS, SVN, Clear Case, Bitkeeper, Git",details:["1. RCS: 공유 폴더 방식, 잠금 후 1명만 수정","2. CVS: 클라이언트/서버 방식, 동시 접근 가능","3. SVN: 클라이언트/서버 방식","4. Clear Case: 복수 클라이언트/복수 서버, 필요 시 서버 증설 가능","5. Bitkeeper: 분산 저장소 방식","6. Git: 분산 저장소 방식 (가장 많이 사용)"]},{title:"형상관리 주요 명령어 (Git / SVN)",mnemonic:null,summary:"init, clone/checkout, add, commit, diff, branch, merge, push 등",details:["1. 생성: git init | svn import","2. 복제: git clone | svn checkout","3. 커밋: git commit | svn commit","4. 변경 내용 확인: git diff | svn diff","5. 추가: git add | svn add","6. 이동: git mv | svn mv","7. 삭제: git rm | svn rm","8. 브랜치 생성: git branch | svn copy","9. 병합: git merge | svn merge","10. 원격 저장소 반영: git push | svn commit (서버 반영)","11. 설정/정보 확인: git config | svn info"]}]},{section:"모듈, 응집도와 결합도",items:[{title:"모듈",mnemonic:null,summary:"독립적으로 완전한 기능을 수행하는 실체 (재사용 가능한 기능 단위)",details:["기능 단위로 분해·추상화된 프로그램 구성 단위","독립적으로 이해·개발·테스트 가능","재사용성, 유지보수성 향상"]},{title:"모듈화",mnemonic:null,summary:"성능 향상과 유지 관리를 위해 기능 단위로 모듈을 분해하는 기법",details:["시스템을 여러 모듈로 나누어 설계하는 방법","복잡성을 줄이고 재사용과 변경 용이성을 높임"]},{title:"루틴 / 메인 루틴 / 서브 루틴",mnemonic:null,summary:"특정 동작을 수행하는 코드 묶음과 그 호출 구조",details:["루틴: 특정 동작을 수행하는 일련의 코드","메인 루틴: 전체 개략적인 절차를 표시하고 서브 루틴을 호출","서브 루틴: 메인 루틴에 의해 호출되어 세부 작업을 수행"]},{title:"응집도 (Cohesion)",mnemonic:null,summary:"모듈 내부 구성 요소들 간의 연관 정도",details:["모듈 내부가 얼마나 하나의 기능에 집중되어 있는가를 나타내는 척도","응집도가 높을수록 좋은 설계"]},{title:"응집도 유형",mnemonic:"우논시절통순기",summary:"우연적, 논리적, 시간적, 절차적, 통신적, 순차적, 기능적",details:["낮음 → 높음 순서:","1) 우연적 응집도 (Coincidental)","2) 논리적 응집도 (Logical)","3) 시간적 응집도 (Temporal)","4) 절차적 응집도 (Procedural)","5) 통신적 응집도 (Communicational)","6) 순차적 응집도 (Sequential)","7) 기능적 응집도 (Functional)"]},{title:"우연적 응집도 (Coincidental Cohesion)",mnemonic:null,summary:"서로 연관 없는 기능이 우연히 한 모듈에 묶여있는 경우",details:["서로 다른 상위 모듈에 의해 호출되는, 연관 없는 기능들이 한 모듈에 모여 있음","가장 안 좋은 형태의 응집도"]},{title:"논리적 응집도 (Logical Cohesion)",mnemonic:null,summary:"유사하거나 같은 범주로 분류되는 기능들이 함께 모여 있는 경우",details:["논리적으로 비슷한 기능이 한 모듈에 묶여 있음","예: 입력 처리 루틴, 출력 처리 루틴 등을 한 곳에 모아둔 경우"]},{title:"시간적 응집도 (Temporal Cohesion)",mnemonic:null,summary:"특정 시간에 함께 수행되는 기능들이 모여 있는 경우",details:["프로그램 시작 시 초기화 작업처럼, 같은 시점에 실행되는 기능 묶음"]},{title:"절차적 응집도 (Procedural Cohesion)",mnemonic:null,summary:"여러 기능이 순차적인 절차에 따라 수행되는 경우",details:["모듈의 여러 기능이 일정한 순서에 따라 실행되도록 구성","절차의 흐름에 초점"]},{title:"통신적 응집도 (Communicational Cohesion)",mnemonic:null,summary:"동일한 입출력 데이터를 사용해 다른 기능을 수행하는 경우",details:["같은 데이터(입출력)를 공유하지만 역할은 서로 다른 기능들이 한 모듈에 포함"]},{title:"순차적 응집도 (Sequential Cohesion)",mnemonic:null,summary:"한 기능의 출력이 다음 기능의 입력으로 사용되는 경우",details:["출력 결과를 다른 구성 요소가 입력으로 사용","데이터 흐름에 기반한 응집도"]},{title:"기능적 응집도 (Functional Cohesion)",mnemonic:null,summary:"모든 구성 요소가 하나의 기능(목적)을 위해 협력하는 경우",details:["모듈 내부의 모든 기능이 하나의 명확한 목적을 위해 수행","가장 바람직한(높은) 응집도 형태"]},{title:"결합도 (Coupling)",mnemonic:null,summary:"모듈 간 상호 의존 정도",details:["모듈이 다른 모듈에 얼마나 의존하는지를 나타냄","결합도는 낮을수록 좋은 설계"]},{title:"결합도 유형",mnemonic:"내공외제스자",summary:"내부, 공통, 외부, 제어, 스탬프, 자료 결합도",details:["높음 → 낮음 순서:","1) 내부(내용) 결합도","2) 공통 결합도","3) 외부 결합도","4) 제어 결합도","5) 스탬프 결합도","6) 자료 결합도"]},{title:"내부(내용) 결합도 (Content Coupling)",mnemonic:null,summary:"다른 모듈의 내부 변수나 기능을 직접 사용하는 경우",details:["한 모듈이 다른 모듈의 내부 구현에 직접 접근","가장 나쁜 형태의 결합도"]},{title:"공통 결합도 (Common Coupling)",mnemonic:null,summary:"공통 데이터(전역 변수)를 여러 모듈이 공유하는 경우",details:["전역 변수에 여러 모듈이 접근","공통 데이터 변경 시 영향 범위가 넓어짐"]},{title:"외부 결합도 (External Coupling)",mnemonic:null,summary:"외부 데이터 포맷, 인터페이스, 프로토콜 등을 공유하는 경우",details:["외부 장치나 프로토콜, 데이터 형식에 의존"]},{title:"제어 결합도 (Control Coupling)",mnemonic:null,summary:"다른 모듈의 내부 논리를 제어하는 정보(플래그)를 전달하는 경우",details:["제어 신호(플래그)를 전달하여 상대 모듈의 동작을 제어","if/else 분기를 유발하는 플래그 전달 등"]},{title:"스탬프 결합도 (Stamp Coupling)",mnemonic:null,summary:"배열, 구조체, 객체 등 복합 자료형을 인터페이스로 전달하는 경우",details:["필요 이상의 필드를 포함한 구조 전체를 전달","전달되는 자료 구조 일부만 실제로 사용되는 경우 많음"]},{title:"자료 결합도 (Data Coupling)",mnemonic:null,summary:"필요한 데이터만 파라미터로 전달하여 상호작용하는 경우",details:["인터페이스로 단순 데이터(값)만 전달","가장 바람직한(낮은) 결합도 형태"]},{title:"팬인 (Fan-in)",mnemonic:null,summary:"어떤 모듈을 호출하는 상위 모듈의 수",details:["해당 모듈을 사용하는 상위 모듈의 개수","높을수록 재사용성이 높다고 볼 수 있음"]},{title:"팬아웃 (Fan-out)",mnemonic:null,summary:"어떤 모듈이 호출하는 하위 모듈의 수",details:["해당 모듈이 제어(호출)하는 다른 모듈의 개수","너무 크면 복잡도가 증가하고 유지보수가 어려워짐"]}]},{section:"서버 프로그램 구조와 배치 처리",items:[{title:"서버 프로그램 구현 방식",mnemonic:"디스다써클",summary:"DTO/VO → SQL → DAO → Service → Controller 순으로 구현",details:["1. DTO/VO: 데이터 전송/값 객체","2. SQL: 데이터 조작을 위한 SQL 작성","3. DAO: DB에 실제 접근하는 계층","4. Service Class: 비즈니스 로직 구현","5. Controller Class: 요청/응답 처리 및 서비스 호출"]},{title:"DTO (Data Transfer Object)",mnemonic:null,summary:"화면/레이어 간 데이터 전달을 위한 객체",details:["계층 간 데이터 전송을 위해 사용되는 객체","주로 Request/Response 형식으로 사용"]},{title:"VO (Value Object)",mnemonic:null,summary:"값 그 자체를 표현하는 간단한 객체",details:["불변 객체로 쓰이는 경우가 많음","값 비교, 의미 전달 등에 사용"]},{title:"MyBatis",mnemonic:null,summary:"자바의 DB 프로그래밍을 돕는 퍼시스턴스 프레임워크",details:["SQL을 XML 또는 애노테이션으로 분리하여 관리","ORM이라기보다는 SQL 매퍼 성격"]},{title:"DAO (Data Access Object)",mnemonic:null,summary:"실질적으로 DB에 접근하는 계층/객체",details:["SQL 실행, 결과 매핑 등을 담당","Service 계층에서 DAO를 사용해 데이터 조작"]},{title:"배치 프로그램",mnemonic:null,summary:"사용자와 상호작용 없이 일련의 작업을 일괄 처리하는 프로그램",details:["대량 데이터 처리, 정기 집계, 로그 정리 등에 사용","실시간이 아닌 비실시간 처리 목적"]},{title:"배치 프로그램 유형",mnemonic:"이온정",summary:"이벤트 배치, 온디맨드 배치, 정기 배치",details:["1. 이벤트 배치: 사전에 정의된 조건이 충족될 때 실행","2. 온디맨드 배치: 사용자의 요구(요청)가 있을 때 실행","3. 정기 배치: 매일/매주 등 정해진 시점에 실행"]},{title:"이벤트 배치",mnemonic:null,summary:"특정 이벤트/조건 발생 시 자동 실행되는 배치",details:["예: 특정 상태가 되었을 때, 로그가 일정량 이상 쌓였을 때 등"]},{title:"온디맨드 배치",mnemonic:null,summary:"사용자 요청 시점에 수동 또는 API로 실행",details:["관리자 화면에서 버튼을 눌러 실행하는 형식 등"]},{title:"정기 배치",mnemonic:null,summary:"스케줄에 따라 주기적으로 실행",details:["예: 매일 새벽 3시 정산, 매월 말 데이터 집계 등"]},{title:"배치 스케줄러",mnemonic:null,summary:"반복적인 배치 작업을 자동으로 수행해주는 도구",details:["정해진 크론 표현식 또는 설정에 따라 배치 작업 실행","재시도, 로그 관리 등을 지원하는 경우도 많음"]},{title:"배치 스케줄러 종류",mnemonic:"스쿼",summary:"스프링 배치, 쿼츠 스케줄러",details:["1. 스프링 배치: 스프링 프레임워크에서 사용하는 배치 프레임워크","2. 쿼츠 스케줄러(Quartz): Job과 Trigger를 분리하는 오픈 소스 스케줄러"]},{title:"쿼츠 크론 표현식",mnemonic:null,summary:"스케줄러에서 배치 수행 시간을 설정하는 표현식",details:["초, 분, 시, 일, 월, 요일, 연도 순으로 표현","Job 실행 시점과 주기를 세밀하게 설정 가능"]},{title:"크론 표현식 필드와 기호",mnemonic:"초분시일월요연",summary:"초-분-시-일-월-요일-연도, 특수기호 사용",details:["필드: 초, 분, 시, 일, 월, 요일, 연도(선택)","요일: 1=SUN, 7=SAT","* : 모든 수","? : 필드 미사용","- : 기간 설정 (예: 1-5)",", : 여러 값 지정 (예: 1,3,5)","/ : 시작값과 반복 간격 (예: 0/5 = 0부터 5간격)","L : 마지막 (마지막 일, 마지막 요일 등)","W : 가장 가까운 평일","# : 몇 번째 주, 요일 (예: 2#1=첫 번째 월요일)"]},{title:"크론 표현식 예시",mnemonic:null,summary:"대표적인 스케줄링 패턴 예시 모음",details:["0 0 12 * * ?           : 매일 12시에 실행","0 * 14 * * ?           : 매일 14:00~14:59까지 매 분마다 실행","0 0/5 14,20 * * ?      : 매일 14시와 20시에 5분 간격으로 실행","0 0 20 ? * MON-FRI     : 매주 월~금 20시에 실행","0 15 10 L * ?          : 매달 마지막 날 10시 15분에 실행","0 15 10 ? * 6L 2020-2021 : 2020~2021년 매달 마지막 금요일 10시 15분에 실행","0 11 11 1 1 ?          : 매년 1월 1일 11시 11분에 실행","0 0 9 15 * ?           : 매달 15일 9시에 실행","0 0 9 15W * ?          : 매달 15일 9시에 실행하되, 15일이 주말이면 가까운 평일에 실행"]}]}];export{e as cert8Data};
