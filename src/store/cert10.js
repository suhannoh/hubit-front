export const cert10Data = [
  {
    section: "결함, 품질, 코드 분석",
    items: [
      {
        title: "소프트웨어 결함 용어",
        mnemonic: null,
        summary: "Error, Defect(Bug), Failure/Problem",
        details: [
          "Error/오류: 사람(개발자)에 의해 생성되는 실수, Defect의 원인",
          "Defect/Bug: Error로 인해 산출물에 포함된 결함, 제거되지 않으면 Failure/Problem으로 이어짐",
          "Failure/Problem: Defect가 실제로 실행될 때 나타나는 잘못된 동작이나 현상"
        ]
      },
      {
        title: "테스트 커버리지",
        mnemonic: "기라코",
        summary: "테스트 수행 정도를 나타내는 값",
        details: [
          "기능 기반 커버리지: 전체 기능을 모수로 측정",
          "라인 커버리지: 소스 코드 라인 수를 모수로 측정",
          "코드 커버리지: 구문(코드) 자체가 얼마나 테스트되었는가를 측정 (일반적으로 커버리지라 하면 코드 커버리지 의미)"
        ]
      },
      {
        title: "리팩토링",
        mnemonic: null,
        summary: "기능은 유지, 내부 코드를 개선해 품질/유지보수성 향상",
        details: [
          "코드 외부 동작(기능)은 동일하게 유지",
          "목적: 유지보수성 향상, 품질 향상, 생산성 향상, 시스템 유연성 향상"
        ]
      },
      {
        title: "클린 코드와 원칙",
        mnemonic: "가단의 중추",
        summary: "가독성 높고 단순하며 중복이 없고 추상화가 잘 된 코드",
        details: [
          "가독성: 누구나 쉽게 읽고 이해할 수 있어야 함",
          "단순성: 불필요한 복잡성 최소화",
          "의존성 최소화: 모듈 간 결합을 줄임",
          "중복 제거: 중복 코드를 제거해 유지보수성 향상",
          "추상화: 적절한 수준으로 개념을 감추고 표현"
        ]
      },
      {
        title: "코드 품질 분석 도구",
        mnemonic: null,
        summary: "정적 분석 vs 동적 분석 도구",
        details: [
          "정적 분석 도구: 실행하지 않고 소스 코드를 분석",
          " - pmd, cppcheck, SonarQube, checkstyle, cobertuna",
          "동적 분석 도구: 실행 중인 프로그램 동작을 분석",
          " - Avalanche, Valgrind"
        ]
      },
      {
        title: "스파게티 코드 & 베드 코드 & 외계인 코드",
        mnemonic: "베드 코드 유형: 오문이 결침",
        summary: "읽기 어렵고 유지보수 힘든 코드들",
        details: [
          "스파게티 코드: 동작은 하지만 내부 구조가 복잡해 파악하기 어려운 코드",
          "외계인 코드: 너무 오래되거나 작성자/문서가 없어 유지보수하기 힘든 코드",
          "베드 코드(일반): 다른 개발자가 로직을 이해하기 어려운 코드",
          "베드 코드 유형:",
          " - 오염: 실제 비즈니스 기능을 수행하지 못하는 컴포넌트가 많음",
          " - 문서 부족: 코드와 문서 불일치",
          " - 의미 없는 이름: 변수/함수 이름이 의도를 드러내지 못함",
          " - 높은 결합도: 모듈 간 의존성이 높음",
          " - 아키텍처 침식: 설계 의도와 다르게 구조가 변형되어 품질 저하"
        ]
      }
    ]
  },

  {
    section: "성능 테스트와 성능 분석",
    items: [
      {
        title: "성능 테스트 수행 방법",
        mnemonic: "도환시성",
        summary: "도구 설치 → 환경설정 → 시나리오 작성 → 성능 테스트 실행/모니터링",
        details: [
          "1. 성능 테스트 도구 설치",
          "2. 환경설정 (서버, 네트워크, 테스트 도구 설정 등)",
          "3. 시나리오 작성 (사용자 행동, 부하 패턴 정의)",
          "4. 성능 테스트 실행 및 모니터링"
        ]
      },
      {
        title: "성능 저하 원인 - DB 관련",
        mnemonic: "락페 릭사커",
        summary: "Lock, Fetch, Connection Leak, Pool Size, Commit",
        details: [
          "DB Lock: 잠금 해제 시까지 대기 → 타임아웃, 지연",
          "불필요한 DB Fetch: 과도한 데이터 요청, 결과 세트 끝까지 커서 이동 등으로 응답시간 증가",
          "Connection Leak: JDBC 객체 사용 후 닫지 않아 커넥션이 반납되지 않는 상황",
          "부적절한 DB Connection Pool Size: 너무 작으면 대기 증가, 너무 크면 자원 낭비",
          "커밋 관련: 트랜잭션 커밋이 지연되거나 불필요한 빈번한 커밋으로 성능 저하"
        ]
      },
      {
        title: "성능 분석 지표",
        mnemonic: "처응경사",
        summary: "처리량, 응답시간, 경과시간, 자원 사용률",
        details: [
          "처리량(Throughput): 일정 시간 동안 처리 가능한 트랜잭션/페이지 수",
          "응답시간(Response Time): 입력 → 응답 출력 개시까지의 시간",
          "경과시간(Turnaround Time): 입력 → 처리 → 결과 출력까지 전체 시간",
          "자원 사용률(Resource Utilization): CPU, 메모리, 디스크 등 사용량"
        ]
      },
      {
        title: "성능 테스트 유형",
        mnemonic: "부스스내",
        summary: "부하, 스트레스, 스파이크, 내구성 테스트",
        details: [
          "부하 테스트(Load): 부하를 점점 증가시켜 임계점을 찾는 테스트",
          "스트레스 테스트(Stress): 임계점 이상의 부하에서 시스템의 동작을 확인",
          "스파이크 테스트(Spark): 짧은 시간 내 많은 사용자가 몰릴 때 반응 확인",
          "내구성 테스트(Endurance): 오랜 시간 높은 부하로 성능·리소스 누수 여부 확인"
        ]
      }
    ]
  },

  {
    section: "결함 우선순위, 심각도, 관리",
    items: [
      {
        title: "결함 우선순위",
        mnemonic: "크+하미로",
        summary: "수정의 긴급도/우선순위",
        details: [
          "Critical: 이 결함으로 전체 기능이 동작하지 않음",
          "High: 이 결함으로 다른 주요 기능이 동작하지 않음",
          "Medium: 보통 수준의 우선순위",
          "Low: 영향이 적어 가장 낮은 우선순위"
        ]
      },
      {
        title: "결함 심각도",
        mnemonic: "크메노마심",
        summary: "사용자/시스템에 미치는 영향 정도",
        details: [
          "Critical (치명적): 테스트 자체가 불가능할 정도의 결함",
          "Major (주요): 요구 기능이 기대와 다르게 동작",
          "Normal (보통): 사소한 기능 오작동",
          "Minor (경미): UI, 화면 표현 등의 오류",
          "Simple (단순): 미관을 해치는 수준"
        ]
      },
      {
        title: "결함 분류",
        mnemonic: "시기지문",
        summary: "시스템/기능/GUI/문서 결함",
        details: [
          "시스템 결함: 비정상 종료, DB 에러 등 시스템 자체 문제",
          "기능 결함: 요구사항 불일치, 스크립트 에러",
          "GUI 결함: 부정확한 메세지, 화면 표시 오류",
          "문서 결함: 매뉴얼, 산출물이 실제 동작과 불일치"
        ]
      },
      {
        title: "결함 분석 관련 용어",
        mnemonic: null,
        summary: "에이징, 추세, 분포, 추이",
        details: [
          "결함 에이징 분석: 특정 결함이 얼마 동안 지속되는지(미해결 기간) 측정",
          "결함 추세 분석: 테스트 시간의 흐름에 따른 결함 발생 수 분석",
          "결함 분포 분석: 특정 속성(모듈, 기능, 유형 등)에 해당하는 결함 수 분석",
          "결함 추이 분석(분추에): 결함 지표를 바탕으로 향후 결함 발생을 추정"
        ]
      },
      {
        title: "결함 생명 주기",
        mnemonic: null,
        summary: "Open → Reviewed → Assigned → Resolved → Verified → Closed (+ Deferred, Reopen)",
        details: [
          "Open: 결함이 등록된 상태",
          "Reviewed: 결함 상세 검토 완료",
          "Assigned: 담당자에게 할당됨",
          "Resolved: 개발자가 수정 완료",
          "Verified: 테스터가 수정 여부 재확인",
          "Closed: 결함이 최종적으로 종료",
          "Deferred: 후순위로 미루어 둔 상태",
          "Reopen: 수정 실패/미흡으로 다시 오픈"
        ]
      },
      {
        title: "결함 분석 방법",
        mnemonic: "고구일",
        summary: "고립화, 구체화, 일반화",
        details: [
          "고립화: 입력값, 절차, 환경 중 어느 요소가 결함에 영향을 주는지 분리",
          "구체화: 영향을 주는 입력값, 절차, 환경을 정확하게 특정",
          "일반화: 결함에 영향을 주는 요소를 최대한 일반화해 패턴 파악"
        ]
      },
      {
        title: "결함 관리 프로세스",
        mnemonic: "계기검수 재추최",
        summary: "계획 → 기록 → 검토 → 수정 → 재검토 → 추적 → 최종 분석/보고",
        details: [
          "1. 결함 관리 계획 수립",
          "2. 결함 관리 DB에 기록",
          "3. 결함 검토 (유효성, 범위 판단)",
          "4. 결함 수정",
          "5. 결함 재검토 (재테스트)",
          "6. 결함 추적 및 모니터링",
          "7. 최종 결함 분석 및 보고서 작성"
        ]
      },
      {
        title: "테스트 리포팅",
        mnemonic: "정요품 결실",
        summary: "테스트 결과를 정리하고 품질 상태를 공유",
        details: [
          "테스트 결과 정리",
          "테스트 요약 문서 작성",
          "품질 상태 파악",
          "결과서 작성",
          "테스트 실행 절차 리뷰 및 평가"
        ]
      }
    ]
  },

  {
    section: "테스트 자동화, 통합/시스템/인수 테스트",
    items: [
      {
        title: "테스트 자동화 도구 유형",
        mnemonic: "정실성통",
        summary: "정적, 실행, 성능, 통제 도구",
        details: [
          "정적 분석 도구: 소스 코드를 실행하지 않고 검사",
          "테스트 실행 도구: 스크립트를 실행하여 자동 테스트 (데이터 주도 vs 키워드 주도)",
          "성능 테스트 도구: 처리량·응답시간·자원 사용률 측정",
          "테스트 통제 도구: 형상 관리 도구, 결함 추적 도구 등"
        ]
      },
      {
        title: "테스트 레벨",
        mnemonic: "단통시인",
        summary: "단위, 통합, 시스템, 인수 테스트",
        details: [
          "단위 테스트: 모듈, 컴포넌트, 서브 루틴 등 설계 최소 단위를 테스트",
          "통합 테스트: 단위 테스트를 통과한 모듈 간 인터페이스, 상호작용 테스트 (빅뱅/상향식/하향식/샌드위치)",
          "시스템 테스트: 기능/비기능 요구사항을 포함한 통합 시스템 검증",
          "인수 테스트: 계약상 요구사항 만족 여부 확인 (알파/베타 테스트 포함)"
        ]
      },
      {
        title: "상향식/하향식/샌드위치/빅뱅 테스트",
        mnemonic: null,
        summary: "통합 방법에 따른 테스트 방식",
        details: [
          "상향식 테스트: 최하위 모듈부터 상위로 통합",
          " - 하위 모듈을 클러스터로 결합",
          " - 드라이버 개발 (상위 모듈 역할)",
          " - 통합된 클러스터 테스트 후 실제 모듈로 드라이버 교체",
          "하향식 테스트: 메인 제어 모듈부터 하위로 통합",
          " - 초기 시스템 구조 파악",
          " - 스텁 개발 (하위 모듈 역할)",
          " - 깊이-우선 또는 너비-우선 방식으로 스텁을 실제 모듈로 교체",
          "샌드위치 테스트: 상위 모듈은 하향식, 하위 모듈은 상향식으로 동시에 수행",
          "빅뱅 테스트: 모든 모듈/컴포넌트를 한 번에 통합해 테스트 (비점증 방식)"
        ]
      },
      {
        title: "테스트 더블 / 하네스 / 목 객체",
        mnemonic: "목스드 슈스케",
        summary: "테스트를 돕는 가짜 객체와 환경",
        details: [
          "테스트 하네스: 단위 테스트를 지원하는 코드와 데이터 집합",
          "가짜 객체(Fake): 협력 클래스의 기능을 간단한 구현으로 대체",
          "테스트 드라이버: 하위 모듈을 호출하고 파라미터를 전달하는 모듈 (상향식에 사용)",
          "테스트 스텁: 특정 값을 리턴하거나 메세지를 출력하는 단순 더미 모듈 (하향식에 사용)",
          "테스트 스파이: 테스트 대상이 협력 클래스에 넘기는 출력을 기록/검증",
          "목 객체(Mock): 사전에 정의한 조건에 따라 예정된 행위를 수행하는 가짜 객체",
          "목 객체 유형: 테스트 스텁, 테스트 드라이버, 테스트 스파이, 가짜 객체"
        ]
      },
      {
        title: "시스템/인수 테스트",
        mnemonic: null,
        summary: "시스템 전체 vs 사용자/계약 기준 테스트",
        details: [
          "시스템 테스트: 통합된 시스템에 대해 기능·비기능 요구사항 검증",
          "인수 테스트: 계약상 요구사항을 만족하는지 확인",
          " - 알파 테스트: 통제된 환경, 선택된 사용자가 개발자와 함께 테스트",
          " - 베타 테스트: 실제 사용 환경에서 수행"
        ]
      }
    ]
  },

  {
    section: "테스트 오라클, 케이스, 경험 기반 테스트",
    items: [
      {
        title: "테스트 오라클",
        mnemonic: "참샘휴일",
        summary: "결과의 참/거짓 판단 기준",
        details: [
          "테스트 오라클: 테스트 결과가 참/거짓인지 판단하기 위한 사전 정의된 참값",
          "참 오라클(True): 모든 입력값에 대한 기대 결과를 생성, 모든 오류 검출 가능",
          "샘플링 오라클(Sampling): 일부 입력값에 대해서만 기대 결과를 제공",
          "휴리스틱 오라클(Heuristic): 일부는 정확한 결과, 나머지는 휴리스틱으로 처리 (샘플링 개선)",
          "일관성 검사 오라클(Consistent): 변경 전/후 결과가 동일한지 확인"
        ]
      },
      {
        title: "테스트 케이스 구성요소",
        mnemonic: "입출항 특환 의식",
        summary: "입력, 출력, 항목, 특수절차, 환경, 의존성, 식별자",
        details: [
          "입력 명세: 입력 데이터 및 조건",
          "출력 명세: 기대되는 결과 값",
          "테스트 항목: 무엇을 검증하는지",
          "특수 절차 요구: 특별한 준비나 절차",
          "환경 설정: 필요한 HW/SW 환경",
          "의존성 기술: 다른 TC와의 의존 관계",
          "식별자: TC 고유 식별 번호"
        ]
      },
      {
        title: "테스트 산출물",
        mnemonic: null,
        summary: "체크리스트, TC, 테스트 슈트, 시나리오, 스크립트",
        details: [
          "체크리스트: 테스트 내용을 목록화한 문서 (재사용 목적)",
          "테스트 케이스(Test Case): 요구사항 검증을 위한 입력값, 실행 조건, 기대 결과 명세",
          "테스트 슈트(Test Suite): 실행 환경 등에 따라 묶어둔 TC 집합",
          "테스트 시나리오(Test Scenario): 테스트할 기능/상황을 절차 중심으로 정리한 문서",
          "테스트 스크립트(Test Script): TC를 실행 순서대로 작성한 문서 (=테스트 스텝, 테스트 프로시저)"
        ]
      },
      {
        title: "경험 기반 테스트",
        mnemonic: "탐오체특",
        summary: "테스터의 경험/직관을 바탕으로 한 테스트",
        details: [
          "오류 추정: 개발자가 범하기 쉬운 실수를 추정해 그에 맞는 TC 설계",
          "탐색적 테스트: TC를 명세화하지 않고 경험·휴리스틱에 의존해 탐색적으로 테스트",
          "체크리스트 테스트: 체크리스트를 기반으로 테스트",
          "특성 테스트: ISO/IEC 9126 등 품질 특성을 기반으로 테스트"
        ]
      }
    ]
  },

  {
    section: "블랙박스 / 화이트박스 / 정적 테스트",
    items: [
      {
        title: "블랙박스 테스트",
        mnemonic: "상원동경비분페유결",
        summary: "요구사항·명세 기반 기능 테스트",
        details: [
          "정의: 내부 구조를 보지 않고, 요구사항/명세를 기준으로 기능 위주 테스트 (명세 기반, 동적 테스트)",
          "주요 유형:",
          " - 상태 전이 테스트",
          " - 원인-결과 그래프 테스트",
          " - 동등 분할 테스트",
          " - 경곗값 분석 테스트",
          " - 비교 테스트",
          " - 분류 트리 테스트",
          " - 페어와이즈 테스트",
          " - 유스케이스 테스트",
          " - 결정(결과) 테이블 테스트(Decision Table Testing)"
        ]
      },
      {
        title: "블랙박스 세부 기법",
        mnemonic: null,
        summary: "여러 입력 조합·상태·경계·원인/결과를 기반으로 TC 설계",
        details: [
          "결정 테이블 테스트: 원인(조건)과 결과(행위)를 표로 정리하여 조합 시험",
          "페어와이즈 테스트: 모든 데이터값 쌍이 최소 한 번씩 조합되도록 TC 설계",
          "유스케이스 테스트: 유스케이스의 프로세스 흐름 기반 테스트",
          "비교 테스트: 여러 버전 프로그램에 동일 입력 후 결과 비교",
          "분류 트리 테스트: 트리 구조로 분석·표현 후 클래스 조합으로 TC 생성",
          "동등 분할 테스트: 유효/무효 입력 영역을 그룹화 후 대표값으로 테스트",
          "경곗값 분석 테스트: 최소/최대, 경계 바로 위/아래 값으로 테스트 (2-Value, 3-Value)",
          "원인-결과 그래프 테스트: 입력 간 관계와 출력 영향 분석 후 효율적 TC 선정",
          "상태 전이 테스트: 상태 전이도 → 전이 트리/경로 → 정상/비정상 전이 TC 도출"
        ]
      },
      {
        title: "화이트박스 테스트",
        mnemonic: "구결조조변다기제데",
        summary: "코드 내부 구조·논리 경로 기반 테스트",
        details: [
          "정의: 모듈 내부 구조, 논리 경로를 분석해 테스트 (구조 기반, 동적 테스트)",
          "구문 커버리지(Statement): 모든 명령문을 최소 1회 실행",
          "결정 커버리지(Decision/Branch): 전체 조건식이 참/거짓 한 번씩",
          "조건 커버리지(Condition): 개별 조건식이 참/거짓 한 번씩 (전체 결과 영향은 고려X)",
          "조건/결정 커버리지: 전체 조건식과 개별 조건식 모두 참/거짓 한 번씩",
          "변경 조건/결정 커버리지(MC/DC): 개별 조건식이 다른 조건식의 영향 없이 전체 결과에 독립적으로 영향",
          "다중 조건 커버리지: 모든 조건식 조합을 100% 수행 (N개 조건 → 2^N개 조합)",
          "기본 경로 커버리지(Base Path): 맥케이브 순환복잡도 기반 모든 독립 경로 테스트",
          "제어 흐름 테스트(Control Flow): 제어 구조를 그래프로 나타내어 경로 테스트",
          "데이터 흐름 테스트(Data Flow): 제어 흐름 그래프에 데이터 사용·정의 정보를 추가해 테스트"
        ]
      },
      {
        title: "순환 복잡도와 정적 분석",
        mnemonic: null,
        summary: "정적 분석, 맥케이브 순환복잡도",
        details: [
          "정적 분석: 소스 코드를 실행하지 않고 도구로 분석",
          " - 코딩 표준 점검",
          " - 소스 코드 복잡도 분석 (맥케이브 순환복잡도 등)",
          " - 자료 흐름 분석",
          "순환복잡도 V(G): 독립 경로 수, 테스트 난이도 기준",
          " - V(G) = E - N + 2 (E: 간선 수, N: 노드 수)",
          " - 또는 V(G) = P + 1 (P: 조건문의 수)"
        ]
      },
      {
        title: "리뷰와 정적 테스트",
        mnemonic: null,
        summary: "리뷰/정적 분석으로 결함 조기 검출",
        details: [
          "리뷰: SW의 결함 검출, 진행 상황 파악을 위해 전문가가 수행",
          "리뷰 유형:",
          " - 관리 리뷰: 계획, 일정 등 관리 관점 검토",
          " - 기술 리뷰(코드 리뷰): 설계·코드 등 기술적 검토",
          " - 인스펙션: 저자가 아닌 전문가가 형식적으로 검토 (동료 리뷰)",
          " - 워크스루: 사전 배포 자료 기반의 짧은 회의 형식 검토",
          " - 감사: 표준 준수 여부를 제3자가 검토",
          "정적 테스트: 실행 없이 리뷰와 정적 분석으로 수행"
        ]
      },
      {
        title: "테스트 분류 - 구조/명세/경험",
        mnemonic: "구명경",
        summary: "구조 기반, 명세 기반, 경험 기반 테스트",
        details: [
          "구조 기반 테스트: 내부 논리 흐름 기반 테스트 (화이트박스)",
          "명세 기반 테스트: 명세서를 기반으로 테스트 (블랙박스)",
          "경험 기반 테스트: 유사 프로젝트/도메인 경험을 기반으로 테스트 (탐오체특)"
        ]
      }
    ]
  },

  {
    section: "테스트 목적, 시각, 원칙",
    items: [
      {
        title: "테스트 목적에 따른 분류",
        mnemonic: "회안성 구회병",
        summary: "회복, 안전, 성능, 구조, 회귀, 병행 테스트",
        details: [
          "회복 테스트(Recovery): 일부러 실패를 유도하고 정상 복귀 여부 테스트",
          "안전 테스트(Security): 보안 결함·취약점 점검",
          "성능 테스트(Performance): 응답속도·처리량 등 요구 성능 측정",
          "구조 테스트(Structure): 논리 경로, 코드 복잡도 측정",
          "회귀 테스트(Regression): 수정 이후 새로운 결함이 유입되지 않았는지 확인",
          "병행 테스트(Parallel): 변경 전/후 시스템에 동일 데이터를 입력하여 결과 비교"
        ]
      },
      {
        title: "테스트 시각에 따른 분류",
        mnemonic: null,
        summary: "검증(Verification) vs 확인(Validation)",
        details: [
          "검증(Verification): 개발자 시점, 규격/명세를 만족하는가?",
          "확인(Validation): 사용자 시점, 올바른 SW(사용자가 원하는 SW)인가?"
        ]
      },
      {
        title: "SW 테스트의 필요성",
        mnemonic: "발예향",
        summary: "오류 발견, 오류 예방, 품질 향상",
        details: [
          "오류 발견 관점: 잠재된 오류를 찾아냄",
          "오류 예방 관점: 사전에 오류를 찾아 예방",
          "품질 향상 관점: 요구사항과 기대 수준을 만족하도록 품질을 개선"
        ]
      },
      {
        title: "SW 테스트의 기본 원칙",
        mnemonic: "완살초 정오 집결",
        summary: "완벽 불가, 살충제, 초기에, 정황 의존, 오류-부재, 결함집중, 결함 존재",
        details: [
          "완벽한 테스팅은 불가능: 모든 입력값/경로를 다 시험할 수 없음",
          "살충제 패러독스: 같은 TC 반복 → 새 결함을 찾기 어려움, TC 갱신 필요",
          "초기에 테스팅 시작: 후반으로 갈수록 결함 수정 비용 증가 (요르돈, 눈덩이 법칙)",
          "정황에 의존: SW 성격, 환경에 맞게 테스트 전략을 달리해야 함",
          "오류-부재의 궤변: 결함이 없어도 요구사항을 만족하지 못하면 품질이 높다고 할 수 없음",
          "결함 집중: 80% 결함이 전체 모듈의 20%에서 발견 (파레토 법칙)",
          "결함 존재: 테스트는 결함의 부재를 증명하는 것이 아니라, 결함의 존재 가능성을 드러내는 활동"
        ]
      },
      {
        title: "SW 테스트 정의",
        mnemonic: null,
        summary: "요구사항 만족 여부 확인 + 결함 검출 활동",
        details: [
          "개발된 소프트웨어가 요구사항을 만족하는지 확인",
          "잠재된 결함을 발견해 품질을 향상시키는 활동"
        ]
      }
    ]
  }
];
